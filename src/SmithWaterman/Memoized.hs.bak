module SmithWaterman.Memoized (
  align
)
where

import Data.Array
import Data.List
import qualified Data.Foldable as Foldable

data Action = Both | X | Y 
    deriving (Show, Eq, Ord)

align :: [Char] -> [Char] -> ([Char], [Char])
align s1 s2 = traceBy maxIx ("","") where
                table = buildTable s1 s2
                maxIx = Foldable.foldr byMaxScore (0,0) (indices table) 
                byMaxScore x y = if table!x > table!y then x else y 
                trace' p@(x,y) = trace s1 s2 p table (drop x s1, drop y s2)
                traceBy :: (Int, Int) -> ([Char], [Char]) -> ([Char], [Char])
                traceBy (x,0) (accX,accY) = (take x s1 ++ accX, take x (repeat '-') ++ accY)
                traceBy (0,y) (accX,accY) = (take y (repeat '-') ++ accX, take y s2 ++ accY)
                traceBy p@(x,y) (accX, accY) = (as, bs)
                  where (_,v) = table!p
                        a     = case v of
                                  Both -> s1!!(x-1)
                                  X    -> s1!!(x-1)
                                  Y    -> '-'
                        b     = case v of 
                                  Both -> s2!!(y-1)
                                  X    -> '-'
                                  Y    -> s2!!(y-1)
                        (as,bs) = case v of
                                  Both -> traceBy (x-1, y-1) (a:accX, b:accY)
                                  X    -> traceBy (x-1, y)   (a:accX, '-':accY)
                                  Y    -> traceBy (x,   y-1) ('-':accX, b:accY)
		 

trace :: [Char] -> [Char] -> (Int, Int) -> Array (Int, Int) (Int, Action) -> ([Char],[Char]) -> ([Char],[Char]) 
trace s1 _  (x,0) _ (accX,accY) = (take x s1 ++ accX, take x (repeat '-') ++ accY)
trace _  s2 (0,y) _ (accX,accY) = (take y (repeat '-') ++ accX, take y s2 ++ accY)
trace s1 s2 p@(x,y) table (accX, accY) = (as, bs)
  where (_,v) = table!p
        a = case v of
              Both -> s1!!(x-1)
              X    -> s1!!(x-1)
              Y    -> '-'
        b = case v of 
              Both -> s2!!(y-1)
              X    -> '-'
              Y    -> s2!!(y-1)
        (as,bs) = case v of
                    Both -> trace s1 s2 (x-1, y-1) table (a:accX,   b:accY)
                    X    -> trace s1 s2 (x-1, y)   table (a:accX,   '-':accY)
                    Y    -> trace s1 s2 (x,   y-1) table ('-':accX, b:accY)

buildTable :: String -> String -> Array (Int,Int) (Int, Action)
buildTable s1 s2 = a where
                   n = length s1
                   m = length s2
                   a = array ( (0,0), (n,m) )
                       ( [((0,y), (0,X)) | y <- [0..m]] ++ --Initialize first row to 0
                         [((x,0), (0,Y)) | x <- [1..n]] ++ --Initialize first column to 0
                         [((x,y), maxScore x y) | x <- [1..n], y <- [1..m]] )
                   maxScore x y = bestOf [takeXY, takeX, takeY]
                     where
                        takeXY = ((fst (a!(x-1,y-1))) 
                                    + cmp (s1!!(x-1)) (s2!!(y-1)), Both)
                        takeX  = ((fst (a!(x-1,y))) + gapPenalty,  X)
                        takeY  = ((fst (a!(x,y-1))) + gapPenalty,  Y)

cmp a b | a == b = 2
        | otherwise = -1
gapPenalty = -1

bestOf = maximumBy $ score fst
score mapper x y  = compare (mapper x) (mapper y)  

printArray :: Show a => Array (Int, Int) a -> String
printArray arr =
  unlines [unwords [show (arr ! (x, y)) | x <- [minX..maxX]] | y <- [minY..maxY]]
    where ((minX, minY), (maxX, maxY)) = bounds arr
